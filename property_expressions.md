# 属性表达式

正如前面的例子所示,属性表达式只能引用托管实体的直接属性。在查询创建的时候你已确认解析的属性是托管实体类的属性之一。然而你也能通过遍历嵌套属性来定义约束。假设一个Person拥有含ZipCode的Address。在这个方法名称中
```java
         List<Person> findByAddressZipCode(ZipCode zipCode);
```
创建了一个属性遍历x.address.zipCode。解析算法由理解实体的部分(AddressZipCode)为属性开始并检查与属性同名(未大写)的领域类。如果解析成功则使用那个属性，如果不成功，算法则会按照驼峰法则从右边开始将源拆开为头和尾并找到相应的属性，在我们的实例中，AddressZip和Code。如果算法从头那找到一个属性它会从尾部开始并继续解析，按照上面的方式来拆解尾部。如果第一个拆解不匹配，那么算法会移动到左边的拆分点(Address,ZipCode)继续分析。

虽然这个工作可能会有很多可能，它也可能因为算法选择错误的属性。假设Person类有一个addressZip属性，则算法会匹配第一个分拆点并且基本上会选择一个错误的属性并失败(就像addressZip类型属性没有code属性)。

要解决这种歧义你可以使用\_加在你的方法名字中来手动的定义遍历节点。所以我们的方法名称会看起来像这样：
```java
         List<Person> findByAddress_ZipCode(ZipCode zipCode);
```
我们将下划线作为保留字符 我们强烈建议遵循标志的JAVA命名规范(比如禁止使用下划线在属性命名中而是用驼峰法则替代)。